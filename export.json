[
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/CHANGELOG.md",
    "contents": "## [Unreleased]\n\n## [0.0.1] - 2024-12-10\n\n- Initial release\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/README.md",
    "contents": "# Phlexi::Menu\n\nPhlexi::Menu is a flexible and powerful menu builder for Ruby applications. It provides an elegant way to create hierarchical menus with support for icons, badges, and active state detection.\n\n[![Ruby](https://github.com/radioactive-labs/phlexi-menu/actions/workflows/main.yml/badge.svg)](https://github.com/radioactive-labs/phlexi-menu/actions/workflows/main.yml)\n\n## Table of Contents\n\n- [Features](#features)\n- [Prerequisites](#prerequisites)\n- [Installation](#installation)\n- [Usage](#usage)\n  - [Basic Usage](#basic-usage)\n  - [Menu Items](#menu-items)\n  - [Component Options](#component-options)\n  - [Theming](#theming)\n  - [Badge Components](#badge-components)\n  - [Rails Integration](#rails-integration)\n- [Advanced Usage](#advanced-usage)\n  - [Component Customization](#component-customization)\n  - [Dynamic Menus](#dynamic-menus)\n- [Development](#development)\n- [Contributing](#contributing)\n- [License](#license)\n\n## Features\n\n- Hierarchical menu structure with controlled nesting depth\n- Support for icons and dual-badge system (leading and trailing badges)\n- Intelligent active state detection\n- Flexible theming system\n- Works seamlessly with Phlex components\n- Rails-compatible URL handling\n- Customizable rendering components\n\n## Prerequisites\n\n- Ruby >= 3.2.2\n- Rails (optional, but recommended)\n- Phlex (~> 1.11)\n\n## Installation\n\nAdd this line to your application's Gemfile:\n\n```ruby\ngem 'phlexi-menu'\n```\n\nAnd then execute:\n\n```bash\n$ bundle install\n```\n\n## Usage\n\n### Basic Usage\n\n```ruby\nclass MainMenu < Phlexi::Menu::Component\n  class Theme < Theme\n    def self.theme\n      super.merge({\n        nav: \"bg-white shadow\",\n        items_container: \"space-y-1\",\n        item_wrapper: \"relative\",\n        item_link: \"flex items-center px-4 py-2 hover:bg-gray-50\",\n        item_span: \"flex items-center px-4 py-2\",\n        item_label: \"mx-3\",\n        leading_badge: \"mr-2 px-2 py-0.5 text-xs rounded-full bg-blue-100 text-blue-600\",\n        trailing_badge: \"ml-auto px-2 py-0.5 text-xs rounded-full bg-red-100 text-red-600\",\n        icon: \"h-5 w-5\",\n        active: \"bg-blue-50 text-blue-600\"\n      })\n    end\n  end\nend\n\n# Using the menu\nmenu = Phlexi::Menu.new do |m|\n  m.item \"Dashboard\", \n    url: \"/\", \n    icon: DashboardIcon\n  \n  m.item \"Users\", \n    url: \"/users\", \n    leading_badge: \"Beta\",\n    trailing_badge: \"23\" do |users|\n    users.item \"All Users\", url: \"/users\"\n    users.item \"Add User\", url: \"/users/new\"\n  end\n  \n  m.item \"Settings\", \n    url: \"/settings\", \n    icon: SettingsIcon,\n    leading_badge: CustomBadgeComponent\nend\n\n# In your view\nrender MainMenu.new(menu, max_depth: 2)\n```\n\n### Menu Items\n\nMenu items support several options:\n\n```ruby\nm.item \"Menu Item\",\n  url: \"/path\",              # URL for the menu item\n  icon: IconComponent,       # Icon component class\n  leading_badge: \"Beta\",     # Leading badge (status/type indicators)\n  trailing_badge: \"99+\",     # Trailing badge (counts/notifications)\n  active: ->(context) {      # Custom active state logic\n    context.controller_name == \"products\"\n  }\n```\n\n### Component Options\n\nThe menu component accepts these initialization options:\n\n```ruby\nMainMenu.new(\n  menu,                    # The menu instance\n  max_depth: 3,           # Maximum nesting depth (default: 3)\n  **options               # Additional options passed to templates\n)\n```\n\n### Theming\n\nThe component provides sensible defaults that you can override:\n\n```ruby\nclass CustomMenu < Phlexi::Menu::Component\n  class Theme < Theme\n    def self.theme\n      super.merge({\n        nav: \"bg-white shadow rounded-lg\",\n        items_container: \"space-y-1\",\n        item_wrapper: \"relative\",\n        item_link: \"flex items-center px-4 py-2 hover:bg-gray-50\",\n        item_span: \"flex items-center px-4 py-2\",\n        item_label: \"mx-3\",\n        leading_badge: \"mr-2 px-2 py-0.5 text-xs rounded-full bg-blue-100 text-blue-600\",\n        trailing_badge: \"ml-auto px-2 py-0.5 text-xs rounded-full bg-red-100 text-red-600\",\n        icon: \"h-5 w-5\",\n        active: \"bg-blue-50 text-blue-600\"\n      })\n    end\n  end\nend\n```\n\n### Badge Components\n\nBadges can be either strings or Phlex components:\n\n```ruby\nclass CustomBadgeComponent < ApplicationComponent\n  def template\n    div(class: \"flex items-center\") do\n      span(class: \"h-2 w-2 rounded-full bg-blue-400\")\n      span(class: \"ml-2\") { \"New\" }\n    end\n  end\nend\n\n# Usage\nm.item \"Products\", leading_badge: CustomBadgeComponent\n```\n\n### Rails Integration\n\nIn your controller:\n\n```ruby\nclass ApplicationController < ActionController::Base\n  def navigation\n    @navigation ||= Phlexi::Menu.new do |m|\n      m.item \"Home\", \n        url: root_path, \n        icon: HomeIcon\n      \n      if user_signed_in?\n        m.item \"Account\", \n          url: account_path,\n          trailing_badge: notifications_count do |account|\n          account.item \"Profile\", url: profile_path\n          account.item \"Settings\", url: settings_path\n          account.item \"Logout\", url: logout_path\n        end\n      end\n\n      if current_user&.admin?\n        m.item \"Admin\", \n          url: admin_path, \n          leading_badge: \"Admin\"\n      end\n    end\n  end\n  helper_method :navigation\nend\n```\n\n## Advanced Usage\n\n### Component Customization\n\nYou can customize specific rendering steps:\n\n```ruby\nclass CustomMenu < Phlexi::Menu::Component\n  # Override just what you need\n  def render_item_interior(item)\n    div(class: \"flex items-center gap-2\") do\n      render_leading_badge(item.leading_badge) if item.leading_badge\n      render_icon(item.icon) if item.icon\n      span(class: themed(:item_label)) { item.label.upcase }\n      render_trailing_badge(item.trailing_badge) if item.trailing_badge\n    end\n  end\n\n  def render_leading_badge(badge)\n    div(class: tokens(themed(:leading_badge), \"flex items-center\")) do\n      span { \"●\" }\n      span(class: \"ml-1\") { badge }\n    end\n  end\nend\n```\n\nThe component provides these customization points:\n- `render_items`: Handles collection of items and nesting\n- `render_item_wrapper`: Wraps individual items\n- `render_item_content`: Chooses between link and span rendering\n- `render_item_interior`: Handles the item's internal layout\n- `render_leading_badge`: Renders the leading badge\n- `render_trailing_badge`: Renders the trailing badge\n- `render_icon`: Renders the icon component\n\n### Dynamic Menus\n\nExample of building menus based on user permissions:\n\n```ruby\nPhlexi::Menu.new do |m|\n  # Basic items\n  m.item \"Home\", url: root_path\n  \n  # Authorization-based items\n  if current_user.can?(:manage, :products)\n    m.item \"Products\", url: products_path do |products|\n      products.item \"All Products\", url: products_path\n      products.item \"Categories\", url: categories_path if current_user.can?(:manage, :categories)\n      products.item \"New Product\", url: new_product_path\n    end\n  end\n  \n  # Dynamic items from database\n  current_user.organizations.each do |org|\n    m.item org.name, url: organization_path(org), icon: OrgIcon\n  end\nend\n```\n\n## Development\n\nAfter checking out the repo:\n\n1. Run `bin/setup` to install dependencies\n2. Run `bin/appraise install` to install appraisal gemfiles\n3. Run `bin/appraise rake test` to run the tests against all supported versions\n4. You can also run `bin/console` for an interactive prompt\n\nFor development against a single version, you can just use `rake test`.\n\n## Contributing\n\nBug reports and pull requests are welcome on GitHub at https://github.com/radioactive-labs/phlexi-menu.\n\n1. Fork it\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create new Pull Request\n\n## License\n\nThe gem is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT)."
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/export.rb",
    "contents": "require \"json\"\nrequire \"find\"\n\ndef export_files_to_json(directory, extensions, output_file, exceptions = [])\n  # Convert extensions to lowercase for case-insensitive matching\n  extensions = extensions.map(&:downcase)\n\n  # Array to store file data\n  files_data = []\n\n  # Find all files in directory and subdirectories\n  Find.find(directory) do |path|\n    # Skip if not a file\n    next unless File.file?(path)\n    next if exceptions.any? { |exception| path.include?(exception) }\n\n    # Check if file extension matches any in our list\n    ext = File.extname(path).downcase[1..-1] # Remove the leading dot\n    next unless extensions.include?(ext)\n\n    puts path\n\n    begin\n      # Read file contents\n      contents = File.read(path)\n\n      # Add to our array\n      files_data << {\n        \"path\" => path,\n        \"contents\" => contents\n      }\n    rescue => e\n      puts \"Error reading file #{path}: #{e.message}\"\n    end\n  end\n\n  # Write to JSON file\n  File.write(output_file, JSON.pretty_generate(files_data))\n\n  puts \"Successfully exported #{files_data.length} files to #{output_file}\"\nend\n\n# Example usage (uncomment and modify as needed):\ndirectory = \"/Users/stefan/Documents/plutonium/phlexi-menu\"\nexceptions = [\"/.github/\", \"/.vscode/\", \"gemfiles\", \"pkg\", \"test\", \"node_modules\"]\nextensions = [\"rb\", \"md\", \"yml\", \"yaml\", \"gemspec\"]\noutput_file = \"export.json\"\nexport_files_to_json(directory, extensions, output_file, exceptions)\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/lib/phlexi/menu/builder.rb",
    "contents": "# frozen_string_literal: true\n\nrequire \"phlex\"\n\nmodule Phlexi\n  module Menu\n    module Builder\n      attr_reader :items\n\n      class Item < Phlexi::Menu::Item; end\n\n      def initialize(&)\n        @items = []\n\n        yield self if block_given?\n      end\n\n      def item(label, **, &)\n        new_item = self.class::Item.new(label, **, &)\n        @items << new_item\n        new_item\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/lib/phlexi/menu/component.rb",
    "contents": "# frozen_string_literal: true\n\nrequire \"phlex\"\n\nmodule Phlexi\n  module Menu\n    # Base menu component that other menu renderers can inherit from\n    class Component < COMPONENT_BASE\n      class Theme < Phlexi::Menu::Theme; end\n\n      DEFAULT_MAX_DEPTH = 3\n\n      def initialize(menu, max_depth: DEFAULT_MAX_DEPTH, **options)\n        @menu = menu\n        @max_depth = max_depth\n        @options = options\n        super()\n      end\n\n      def view_template\n        nav(class: themed(:nav)) do\n          render_items(@menu.items)\n        end\n      end\n\n      protected\n\n      # Base implementation handles nesting and delegates individual item rendering\n      def render_items(items, depth = 0)\n        return if depth >= @max_depth\n        return if items.empty?\n\n        ul(class: themed(:items_container)) do\n          items.each do |item|\n            render_item_wrapper(item, depth)\n          end\n        end\n      end\n\n      def render_item_wrapper(item, depth)\n        li(class: tokens(\n          themed(:item_wrapper),\n          active_class(item),\n          item_parent_class(item)\n        )) do\n          render_item_content(item)\n          render_items(item.items, depth + 1) if item.items.any?\n        end\n      end\n\n      def render_item_content(item)\n        if item.url\n          render_item_link(item)\n        else\n          render_item_span(item)\n        end\n      end\n\n      def render_item_link(item)\n        a(href: item.url, class: themed(:item_link)) do\n          render_item_interior(item)\n        end\n      end\n\n      def render_item_span(item)\n        span(class: themed(:item_span)) do\n          render_item_interior(item)\n        end\n      end\n\n      def render_item_interior(item)\n        render_leading_badge(item.leading_badge) if item.leading_badge\n        render_icon(item.icon) if item.icon\n        render_label(item.label)\n        render_trailing_badge(item.trailing_badge) if item.trailing_badge\n      end\n\n      def render_label(label)\n        phlexi_render(label) {\n          span(class: themed(:item_label)) { label }\n        }\n      end\n\n      def render_leading_badge(badge)\n        phlexi_render(badge) {\n          span(class: themed(:leading_badge)) { badge }\n        }\n      end\n\n      def render_trailing_badge(badge)\n        phlexi_render(badge) {\n          span(class: themed(:trailing_badge)) { badge }\n        }\n      end\n\n      def render_icon(icon)\n        return unless icon\n\n        div(class: themed(:icon_wrapper)) do\n          render icon.new(class: themed(:icon))\n        end\n      end\n\n      def active_class(item)\n        item.active?(helpers) ? themed(:active) : nil\n      end\n\n      def item_parent_class(item)\n        item.items.any? ? themed(:item_parent) : nil\n      end\n\n      def themed(component)\n        self.class::Theme.instance.resolve_theme(component)\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/lib/phlexi/menu/item.rb",
    "contents": "# frozen_string_literal: true\n\nrequire \"phlex\"\n\nmodule Phlexi\n  module Menu\n    class Item\n      attr_reader :label, :url, :icon, :leading_badge, :trailing_badge, :items, :options\n\n      def initialize(label, url: nil, icon: nil, leading_badge: nil, trailing_badge: nil, **options, &)\n        @label = label\n        @url = url\n        @icon = icon\n        @leading_badge = leading_badge\n        @trailing_badge = trailing_badge\n        @options = options\n        @items = []\n\n        yield self if block_given?\n      end\n\n      def item(label, **, &)\n        new_item = self.class.new(label, **, &)\n        @items << new_item\n        new_item\n      end\n\n      def active?(context)\n        return @options[:active].call(context) if @options[:active].respond_to?(:call)\n        return context.current_page?(@url) if @url\n\n        @items.any? { |item| item.active?(context) }\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/lib/phlexi/menu/theme.rb",
    "contents": "require \"fiber/local\"\n\nmodule Phlexi\n  module Menu\n    class Theme < Phlexi::Field::Theme\n      def self.theme\n        @theme ||= {\n          nav: nil,\n          items_container: nil,\n          item_wrapper: nil,\n          item_parent: nil,\n          item_link: nil,\n          item_span: nil,\n          item_label: nil,\n          leading_badge: nil,\n          trailing_badge: nil,\n          icon: nil,\n          active: nil\n        }.freeze\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/lib/phlexi/menu/version.rb",
    "contents": "# frozen_string_literal: true\n\nmodule Phlexi\n  module Menu\n    VERSION = \"0.0.1\"\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/lib/phlexi/menu.rb",
    "contents": "# frozen_string_literal: true\n\nrequire \"zeitwerk\"\nrequire \"phlex\"\nrequire \"active_support/core_ext/object/blank\"\n\nmodule Phlexi\n  NIL_VALUE = :__i_phlexi_i__\n\n  module Menu\n    Loader = Zeitwerk::Loader.new.tap do |loader|\n      loader.tag = File.basename(__FILE__, \".rb\")\n      loader.ignore(\"#{__dir__}/menu/version.rb\")\n      loader.inflector.inflect(\n        \"phlexi-menu\" => \"Phlexi\",\n        \"phlexi\" => \"Phlexi\"\n      )\n      loader.push_dir(File.expand_path(\"..\", __dir__))\n      loader.setup\n    end\n\n    COMPONENT_BASE = (defined?(::ApplicationComponent) ? ::ApplicationComponent : Phlex::HTML)\n\n    class Error < StandardError; end\n\n    def self.object_primary_key(object)\n      if object.class.respond_to?(:primary_key)\n        object.send(object.class.primary_key.to_sym)\n      elsif object.respond_to?(:id)\n        object.id\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/lib/phlexi-menu.rb",
    "contents": "# frozen_string_literal: true\n\nrequire_relative \"phlexi/menu/version\"\nrequire_relative \"phlexi/menu\"\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/phlexi-menu/phlexi-menu.gemspec",
    "contents": "# frozen_string_literal: true\n\nrequire_relative \"lib/phlexi/menu/version\"\n\nGem::Specification.new do |spec|\n  spec.name = \"phlexi-menu\"\n  spec.version = Phlexi::Menu::VERSION\n  spec.authors = [\"Stefan Froelich\"]\n  spec.email = [\"sfroelich01@gmail.com\"]\n\n  spec.summary = \"A flexible and powerful menu builder for Ruby applications\"\n  spec.description = \"Phlexi::Menu is a flexible menu builder for Ruby applications that provides hierarchical menus, active state detection, icons, badges, and a powerful theming system. Built with Phlex components, it offers a modern approach to building navigation menus.\"\n  spec.homepage = \"https://github.com/radioactive-labs/phlexi-menu\"\n  spec.license = \"MIT\"\n  spec.required_ruby_version = \">= 3.2.2\"\n\n  spec.metadata[\"allowed_push_host\"] = \"https://rubygems.org\"\n\n  spec.metadata[\"homepage_uri\"] = spec.homepage\n  spec.metadata[\"source_code_uri\"] = spec.homepage\n  spec.metadata[\"changelog_uri\"] = spec.homepage\n\n  # Specify which files should be added to the gem when it is released.\n  # The `git ls-files -z` loads the files in the RubyGem that have been added into git.\n  gemspec = File.basename(__FILE__)\n  spec.files = IO.popen(%w[git ls-files -z], chdir: __dir__, err: IO::NULL) do |ls|\n    ls.readlines(\"\\x0\", chomp: true).reject do |f|\n      (f == gemspec) ||\n        f.start_with?(*%w[bin/ test/ spec/ features/ .git .github appveyor Gemfile])\n    end\n  end\n  spec.bindir = \"exe\"\n  spec.executables = spec.files.grep(%r{\\Aexe/}) { |f| File.basename(f) }\n  spec.require_paths = [\"lib\"]\n\n  spec.add_dependency \"phlex\", \"~> 1.11\"\n  spec.add_dependency \"activesupport\"\n  spec.add_dependency \"zeitwerk\"\n  spec.add_dependency \"fiber-local\"\n\n  spec.add_development_dependency \"rake\"\n  spec.add_development_dependency \"minitest\"\n  spec.add_development_dependency \"minitest-reporters\"\n  spec.add_development_dependency \"standard\"\n  # spec.add_development_dependency \"brakeman\"\n  spec.add_development_dependency \"bundle-audit\"\n  spec.add_development_dependency \"appraisal\"\n  spec.add_development_dependency \"combustion\"\n  spec.add_development_dependency \"phlex-testing-capybara\"\nend\n"
  }
]